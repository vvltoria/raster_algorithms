<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Теория Алгоритмов</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <header>
      <h1>Теория Алгоритмов</h1>
    </header>

    <div class="theory-content">
      <section class="algorithm">
        <h2>1. Алгоритм ЦДА (Цифровой дифференциальный анализ)</h2>
        <p>
          Алгоритм ЦДА используется для рисования прямых отрезков на двумерной сетке
          пикселей. Это один из самых распространенных алгоритмов, который помогает
          вычислять координаты пикселей на основе разницы между координатами концов
          отрезка. Он основан на принципах цифрового дифференциального анализа.
        </p>

        <h3>Шаги алгоритма:</h3>
        <ol>
          <li>Вычисление разности координат:
            <pre><code>dx = x2 - x1
dy = y2 - y1</code></pre>
          </li>
          <li>Вычисление приращений по осям X и Y:
            <pre><code>px = 2 * dy - dx
py = 2 * dx - dy</code></pre>
          </li>
          <li>Если <code>px > 0</code>, то необходимо делать шаг по оси X.</li>
          <li>Если <code>py > 0</code>, то необходимо делать шаг по оси Y.</li>
        </ol>

        <h3>Формулы для вычисления пикселей:</h3>
        <div class="formula-block">
          <pre>
Начальная точка: (x1, y1)
Конечная точка: (x2, y2)
dx = x2 - x1
dy = y2 - y1
если dx >= dy:
  - Начинаем с точки (x1, y1)
  - Идем вдоль оси X
  - В зависимости от значения px, выбираем шаг по оси Y
иначе:
  - Начинаем с точки (x1, y1)
  - Идем вдоль оси Y
  - В зависимости от py, выбираем шаг по оси X
          </pre>
        </div>
      </section>

      <section class="algorithm">
        <h2>2. Алгоритм Брезенхема (Для отрезков)</h2>
        <p>
          Алгоритм Брезенхема используется для рисования прямых отрезков и является
          более оптимизированной и точной версией алгоритма ЦДА. Он минимизирует
          количество вычислений, используя только целочисленные операции.
        </p>

        <h3>Шаги алгоритма:</h3>
        <ol>
          <li>Вычисление разности координат:
            <pre><code>dx = x2 - x1
dy = y2 - y1</code></pre>
          </li>
          <li>Вычисление ошибок и начальных значений:
            <pre><code>2 * dy - dx</code></pre>
          </li>
          <li>Для каждого шага:
            <pre><code>Если ошибка > 0, двигаемся на один пиксель по оси Y и корректируем ошибку.
В противном случае, двигаемся на один пиксель по оси X.</code></pre>
          </li>
        </ol>

        <h3>Формулы для вычисления пикселей:</h3>
        <div class="formula-block">
          <pre>
dx = x2 - x1
dy = y2 - y1
if dx >= dy:
  - Начинаем с точки (x1, y1)
  - Вычисляем ошибку: error = 2*dy - dx
  - Если ошибка > 0, двигаемся на один пиксель по оси Y и корректируем ошибку.
  - В противном случае, двигаемся на один пиксель по оси X.
          </pre>
        </div>
      </section>

      <section class="algorithm">
        <h2>3. Алгоритм Брезенхема (Для окружности)</h2>
        <p>
          Этот алгоритм предназначен для рисования окружностей. Он использует аналогичный
          подход, как и алгоритм для отрезков, но вместо прямой линии мы рассчитываем
          пиксели на окружности с заданным радиусом.
        </p>

        <h3>Шаги алгоритма:</h3>
        <ol>
          <li>Вычисление начальных значений:
            <pre><code>dx = r
dy = 0
err = 1 - r</code></pre>
          </li>
          <li>Для каждого шага:
            <pre><code>Изменяем координаты пикселей в зависимости от значения ошибки.</code></pre>
          </li>
        </ol>

        <h3>Формулы для вычисления пикселей окружности:</h3>
        <div class="formula-block">
          <pre>
Центр окружности: (xc, yc)
Радиус: r
Начальное значение ошибки: error = 1 - r
dx = r
dy = 0

Для каждого шага:
- Если ошибка < 0, двигаемся по оси X.
- Если ошибка > 0, двигаемся по оси Y и корректируем ошибку.
          </pre>
        </div>
      </section>

      <section class="algorithm">
        <h2>4. Пошаговый алгоритм</h2>
        <p>
          Пошаговый алгоритм для рисования отрезка отличается от предыдущих тем, что
          делает каждый шаг более явным и четким для пользователя. В отличие от алгоритмов
          ЦДА и Брезенхема, он использует простую линейную интерполяцию для вычисления
          координат пикселей.
        </p>

        <h3>Шаги алгоритма:</h3>
        <ol>
          <li>Рассчитываем разницу между координатами:
            <pre><code>dx = x2 - x1
dy = y2 - y1</code></pre>
          </li>
          <li>Вычисляем количество шагов:
            <pre><code>steps = max(abs(dx), abs(dy))</code></pre>
          </li>
          <li>Для каждого шага вычисляем инкременты по осям X и Y:
            <pre><code>incrementX = dx / steps
incrementY = dy / steps</code></pre>
          </li>
          <li>Для каждого шага рисуем пиксель и обновляем значения X и Y.</li>
        </ol>

        <h3>Формулы для вычисления пикселей:</h3>
        <div class="formula-block">
          <pre>
Начальная точка: (x1, y1)
Конечная точка: (x2, y2)
dx = x2 - x1
dy = y2 - y1
steps = max(abs(dx), abs(dy))

incrementX = dx / steps
incrementY = dy / steps

Для каждого шага:
- Рисуем пиксель на позиции (x, y)
- Обновляем координаты: x += incrementX, y += incrementY
          </pre>
        </div>
      </section>
    </div>
  </body>
</html>
